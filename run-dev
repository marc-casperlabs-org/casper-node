#!/usr/bin/env python3

# nix-shell -p python3Packages.click -p python3Packages.black -p python3Packages.toml -p python3Packages.requests

# run-dev.sh successor. Requires python `click`, `requests` and `toml` packages installed, which
# should be available in all commonly used distros.

import atexit
import curses
from datetime import datetime, timedelta
import json
import os
import random
import shutil
import subprocess
import sys
import time

import click
import requests
import toml

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
CHAINSPEC_TEMPLATE = os.path.join(BASE_DIR, "resources", "local", "chainspec.toml")
CONFIG_TEMPLATE = os.path.join(BASE_DIR, "resources", "local", "config.toml")

# TODO: TRUSTED HASH
#     TODO systemctl --user reset-failed node-$ID || true
#         TRUSTED_HASH_ARG=--config-ext=node.trusted_hash="${TRUSTED_HASH}"

#: Singleton holding the path of a compiled node. Use `node_path()` instead.
_node_path = None


def node_path():
    """Compiles the casper node once, returns path to `casper-node` binary"""
    global _node_path

    if not _node_path:
        progress("compiling casper-node")
        subprocess.check_call(
            [
                "cargo",
                "build",
                "--release",
                "--quiet",
                "--manifest-path={}".format(
                    os.path.join(BASE_DIR, "node", "Cargo.toml")
                ),
            ]
        )
        _node_path = os.path.abspath(
            os.path.join(BASE_DIR, "target", "release", "casper-node")
        )

    return _node_path


class RunDevError(Exception):
    """A run-dev exception"""

    pass


class Namespace:
    def __init__(
        self,
        name,
        base_dir,
        num_nodes,
        genesis_offset,
        validator_slots,
        node_memory_limit,
    ):
        """A namespace containing all data required to run a full network.

        Includes configuration files and runtime state for all nodes, as well as chainspec data"""
        self.name = name
        self.ns_dir = os.path.join(base_dir, name)
        self.chainspec_toml = os.path.abspath(
            os.path.join(self.ns_dir, "chainspec.toml")
        )
        self.num_nodes = num_nodes
        self.genesis_offset = genesis_offset
        self.validator_slots = validator_slots
        self.node_memory_limit = node_memory_limit

        # Precalculated paths and values.
        self.accounts_csv = os.path.abspath(os.path.join(self.ns_dir, "accounts.csv"))
        self.bootstrap_port = random.Random(self.name).randint(60000, 65000)
        self.nodes = tuple(Node(self, id) for id in range(self.num_nodes))

    def add_asset(self, input_path):
        """Copies a file into the namespace, returns the resulting path"""
        asset_dir = os.path.join(self.ns_dir, "assets")
        if not os.path.exists(asset_dir):
            os.makedirs(asset_dir)

        basename = os.path.basename(input_path)
        dest = os.path.join(asset_dir, basename)
        progress("adding {}".format(basename))
        shutil.copy(input_path, dest)
        return dest

    def destroy(self):
        """Destroys a namespace, stopping all nodes and removing its data"""
        if self.is_initialized():
            for node in self.nodes:
                node.stop()
            progress("destroying namespace {}".format(self.name))
            shutil.rmtree(self.ns_dir)
        else:
            info("namespace {} does not exist".format(self.name))

    def initialize(self):
        """Initializes a namespace"""
        if not self.is_initialized():
            os.makedirs(self.ns_dir)

            # Setup a chainspec
            chainspec = toml.load(open(CHAINSPEC_TEMPLATE))
            chainspec_base = os.path.dirname(CHAINSPEC_TEMPLATE)

            chainspec["genesis"]["mint_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base, chainspec["genesis"]["mint_installer_path"]
                )
            )
            chainspec["genesis"]["pos_installer_path"] = self.add_asset(
                os.path.join(chainspec_base, chainspec["genesis"]["pos_installer_path"])
            )
            chainspec["genesis"]["standard_payment_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base,
                    chainspec["genesis"]["standard_payment_installer_path"],
                )
            )
            chainspec["genesis"]["auction_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base, chainspec["genesis"]["auction_installer_path"]
                )
            )
            chainspec["genesis"]["accounts_path"] = self.accounts_csv
            chainspec["genesis"]["validator_slots"] = self.validator_slots

            # Setup genesis timestamp
            genesis_ts = create_timestamp(self.genesis_offset, datetime.utcnow())
            chainspec["genesis"]["timestamp"] = genesis_ts

            # Save the updated chainspec.
            toml.dump(chainspec, open(self.chainspec_toml, "w"))

            # Setup each node and write accounts file
            accounts = open(self.accounts_csv, "w")
            for node in self.nodes:
                node.initialize()

                # Generate keys for each node and collect them in accounts.csv
                motes = 1000000000000000
                weight = 10000000000000

                progress(
                    "adding account {} with {} motes and {} weight".format(
                        click.style(node.hex_key[:7], fg="cyan", reset=True),
                        motes,
                        weight,
                    )
                )
                accounts.write("{},{},{}\n".format(node.hex_key, motes, weight))

    def is_initialized(self):
        """Returns whether or not the namespace has been intialized.

        Raises an exception if it has been initialized with a different number of nodes"""
        if os.path.exists(self.accounts_csv):
            return True

        if os.path.exists(self.ns_dir):
            raise RunDevError(
                "your namespace is corrupted, please remove {} manually".format(
                    self.ns_dir
                )
            )

        return False

    def node_by_id(self, id):
        """Returns a single node by id."""
        if id >= len(self.nodes):
            raise RunDevError("No such node: {}".format(id))
        return self.nodes[id]

    def nodes_by_ids(self, ids):
        """Returns nodes by id.

        Returns all nodes if `ids` is empty"""
        if not ids:
            return self.nodes

        return [self.node_by_id(id) for id in ids]

    def seconds_until_genesis(self, utc_now):
        """Returns the number of seconds until genesis"""
        # TODO: Factor out.
        chainspec = toml.load(open(self.chainspec_toml))
        timestamp = datetime.fromisoformat(
            chainspec["genesis"]["timestamp"].rstrip("Z")
        )

        return (timestamp - utc_now).total_seconds()


class Node:
    def __init__(self, namespace, id):
        # Basic info.
        self.namespace = namespace
        self.id = id
        self.dir = os.path.join(namespace.ns_dir, "node-{}".format(id))
        self.name = "{}_node-{}".format(namespace.name, id)

        # Derived paths and names.
        self.config_toml = os.path.join(self.dir, "config.toml")
        self.key_dir = os.path.join(self.dir, "keys")
        self.key_path = os.path.join(self.key_dir, "secret_key.pem")
        self.storage_dir = os.path.join(self.dir, "storage")
        self.stderr = os.path.join(self.dir, "stderr")
        self.stdout = os.path.join(self.dir, "stdout")
        self.unit = "{}.service".format(self.name)

        # Ports.
        self.http_port = (
            30000 + random.Random(self.name).randint(0, 150) * 200 + self.id
        )

        # Load key if possible.
        self.try_load_hex_key()

    @property
    def bootstrap_addr(self):
        """Bootstrap address used by node."""
        return "127.0.0.1:{}".format(self.namespace.bootstrap_port)

    def describe(self):
        """Return select attributes from the node"""
        return {
            key: getattr(self, key)
            for key in ("id", "name", "http_addr", "key_dir", "config_toml")
        }

    @property
    def http_addr(self):
        """The nodes HTTP server address"""
        return "127.0.0.1:{}".format(self.http_port)

    def load_status(self):
        """Load the output of the /status endpoint of the node"""
        resp = requests.get("http://" + self.http_addr + "/status")
        resp.raise_for_status()
        return resp.json()

    @property
    def is_bootstrap(self):
        """Is this node a bootstrap node?"""
        return self.id == 0

    def initialize(self):
        """Initializes a node, including storage and config"""
        # Generate a key
        progress("generating key for node {} [{}]".format(self.id, self.key_dir))
        run_client("keygen", self.key_dir)
        self.try_load_hex_key()

        # Ensure the storage dir exists
        if not os.path.exists(self.storage_dir):
            progress("creating storage dir for node {}", self.id)
            os.makedirs(self.storage_dir)

        # Create configuration
        config = toml.load(open(CONFIG_TEMPLATE))
        config["node"]["chainspec_config_path"] = self.namespace.chainspec_toml
        config["consensus"]["secret_key_path"] = self.key_path
        config["storage"]["path"] = self.storage_dir
        config["logging"]["format"] = "json"

        # Setup networking/IPs
        config["network"]["gossip_interval"] = 5000
        config["network"]["systemd_support"] = True
        config["http_server"]["address"] = self.http_addr

        if self.is_bootstrap:
            # Bootstrap node.
            config["network"]["bind_address"] = self.bootstrap_addr
            config["network"]["public_address"] = self.bootstrap_addr
            config["network"]["known_addresses"] = []
        else:
            config["network"]["known_addresses"] = [self.bootstrap_addr]
            config["network"]["bind_address"] = "127.0.0.1:0"
            config["network"]["public_address"] = "127.0.0.1:0"

        # Save config
        progress(
            "saving node configuration for node {} [{}]", self.id, self.config_toml,
        )
        toml.dump(config, open(self.config_toml, "w"))

    def start(self):
        """Start a node, without resetting its state."""
        if unit_exists(self.unit):
            # Unit already exists. Check if it is healthy.
            if unit_is_active(self.unit):
                info(
                    "{} is already running, skipping. stop it first if you want to restart",
                    self.unit,
                )
                return

            # Unit is _not_ healthy. Clean it up
            progress("resetting failed {} before starting", self.unit)
            subprocess.check_call(["systemctl", "--user", "reset-failed", self.unit])

        deps = [] if id == 0 else [self.name]
        if id != 0:
            deps

        progress("starting node {}", self.id)
        systemd_run(
            self.name,
            "casperlabs node {} in namespace {}".format(self.id, self.namespace.name),
            node_path(),
            properties={
                "Type": "notify",
                "TimeoutSec": 10,
                "WorkingDirectory": self.dir,
                "StandardOutput": "file:{}".format(self.stdout),
                "StandardError": "file:{}".format(self.stderr),
                "LimitDATA": self.namespace.node_memory_limit,
            },
            deps=deps,
            env={"RUST_LOG": "debug",},
            app_args=["validator", self.config_toml],
        )

    def status(self, local_now):
        """Returns status information of a node"""
        rv = {
            "id": str(self.id),
            "state": "",
            "since": "",
            "peers": "",
            "last_block": "",
            "info": "",
        }

        us = get_unit(self.unit)
        rv["state"] = us["ActiveState"]

        if "StateChangeTimestamp" in us:
            state_changed = parse_systemd_timestamp(us["StateChangeTimestamp"])
            rv["since"] = human_timedelta((local_now - state_changed).total_seconds())

        # We use the last line from stderr, unless the node did not crash.
        log_source = self.stderr
        if rv["state"] == "active":
            log_source = self.stdout
        if os.path.exists(log_source):
            if log_source == self.stdout:
                log_line = last_lines_of_file(log_source)
                if log_line:
                    data = json.loads(log_line)
                    fields = data["fields"]
                    if "message" in fields:
                        rv["info"] = fields["message"]
                    else:
                        rv["info"] = str(fields)
            else:
                # Stderr uses just abbreviated lines.
                rv["info"] = ellipses(last_lines_of_file(log_source), 35)

        # Active nodes we can query as well
        if rv["state"] == "active":
            # TODO: Handle exceptions
            status = self.load_status()
            rv["peers"] = str(len(status["peers"]))

            block_info = status["last_added_block_info"]
            if block_info:
                rv["last_block"] = str(block_info)

        return rv

    def stop(self):
        """Stops the node, retaining logs and state."""
        progress("stopping node {}", self.id)

        if not unit_exists(self.unit):
            info("{} does not exist, skipping", self.unit)
            return

        if not unit_is_active(self.unit):
            info("{} is not running, skipping", self.unit)
            return

        subprocess.call(["systemctl", "--user", "stop", self.unit])

    def try_load_hex_key(self):
        """Tries to load and set the hex key of the node"""
        hex_key_path = os.path.join(self.key_dir, "public_key_hex")
        if os.path.exists(hex_key_path):
            self.hex_key = open(hex_key_path).read().strip()


@click.group()
@click.option(
    "-b", "--base-dir", default="/tmp/run-dev", help="Base directory to store data in"
)
@click.option(
    "--namespace", "name", default="default", help="Namespace to run nodes in"
)
@click.option(
    "-g",
    "--genesis-offset",
    default=15,
    help="(for new namespace) Offset for genesis in seconds",
)
@click.option(
    "-m",
    "--memory-limit",
    "node_memory_limit",
    default="400M",
    help="(for new namespace) Memory limit per node",
)
@click.option(
    "-n",
    "--num-nodes",
    default=5,
    type=int,
    help="(for new namespace) Total number of nodes in the namespace",
)
@click.option(
    "--validator-slots",
    default=5,
    help="(for new namespace) Number of validator slots in an auction",
)
@click.pass_context
def cli(ctx, **kwargs):
    ctx.obj = Namespace(**kwargs)


@cli.command()
@click.option(
    "-f", "--force", is_flag=True, help="destroy namespace if it already exists"
)
@click.pass_obj
def create(namespace, force):
    """Creates a new namespace"""
    if namespace.is_initialized():
        if not force:
            raise RunDevError("namespace already initialized")
        namespace.destroy()

    namespace.initialize()


@cli.command()
@click.argument("node_id", type=int)
@click.pass_obj
def describe(namespace, node_id):
    """Output information about a single node"""
    if not namespace.is_initialized():
        namespace.initialize()

    description = namespace.node_by_id(node_id).describe()
    json.dump(description, sys.stdout, indent=2, sort_keys=True)


@cli.command()
@click.argument("node_id", type=int)
@click.option("-e", "--stderr", is_flag=True, help="Show stderr logs instead of stdout")
@click.pass_obj
def logs(namespace, node_id, stderr):
    """Stop a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        raise RunDevError("cannot stop nodes, no namespace initialized")

    node = namespace.node_by_id(node_id)
    log_file = node.stderr if stderr else node.stdout

    shutil.copyfileobj(open(log_file, "rb"), sys.stdout.buffer)


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def start(namespace, node_ids):
    """Start a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        namespace.initialize()

    for node in namespace.nodes_by_ids(node_ids):
        node.start()


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def stop(namespace, node_ids):
    """Stop a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        raise RunDevError("cannot stop nodes, no namespace initialized")

    for node in namespace.nodes_by_ids(node_ids):
        node.stop()


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.option("-n", "--delay", type=float, default=1.0, help="Update frequency")
@click.pass_obj
def top(namespace, node_ids, delay):
    """Output status information about nodes"""
    if not namespace.is_initialized():
        raise RunDevError("namespace not initialized, cannot get node status")

    def run_top(stdscr):
        state_table = curses.newwin(20, 80, 1, 0)
        state_table.bkgdset(" ", curses.color_pair(0))
        curses.start_color()
        curses.cbreak()
        curses.curs_set(0)

        stdscr.bkgd(" ", curses.color_pair(1))
        stdscr.clear()

        active_node = -1

        # Poll every 100 ms
        stdscr.timeout(100)

        # Color pair 1: Background
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

        # Color pair 2: Active row.
        curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_GREEN)

        keep_going = True
        while keep_going:
            now = datetime.utcnow()
            local_now = datetime.now()

            rows = [node.status(local_now) for node in namespace.nodes_by_ids(node_ids)]

            # Update screen geometry.
            screen_rows, screen_cols = stdscr.getmaxyx()
            state_table.resize(
                max(screen_rows - 2, len(rows) + 3), max(80, screen_cols)
            )

            # Update the status table
            _, table_width = state_table.getmaxyx()
            state_table.clear()

            # Coordinates for columns (start, end)
            columns = {
                "id": (0, 3),
                "state": (4, 10),
                "since": (11, 22),
                "peers": (23, 27),
                "last_block": (28, 38),
                "info": (39, max(40, table_width)),
            }

            # Draw headings.
            for (col, (begin, end)) in columns.items():
                width = end - begin
                state_table.addnstr(0, begin, col.upper(), width)
                state_table.addnstr(1, begin, "=" * width, width)

            # Draw status values
            for idx, row in enumerate(rows):
                color = 0 if not idx == active_node else 2

                for (col, (begin, end)) in columns.items():
                    width = end - begin
                    value = row[col]

                    if len(value) > width:
                        value = ellipses(value, length=width)

                    state_table.addnstr(idx + 2, begin, value, width, curses.color_pair(color))

            # Draw status bar.
            stdscr.addstr(
                screen_rows - 1,
                0,
                "Genesis in: {}".format(
                    human_timedelta(namespace.seconds_until_genesis(now))
                ),
            )

            stdscr.refresh()
            state_table.refresh()
            stdscr.move(screen_rows - 1, screen_cols - 1)

            entered = time.time()
            while True:
                char = stdscr.getch()

                if char == -1:
                    if time.time() - entered > delay:
                        break
                    else:
                        continue

                # We read a char without a timeout, act on it.
                if char == ord("q"):
                    keep_going = False
                elif char == ord('`'):
                    active_node = -1
                elif char == curses.KEY_UP:
                    active_node = max(active_node-1, 0)
                elif char == curses.KEY_DOWN:
                    active_node = min(active_node+1, len(rows)-1)
                elif char == ord('l') and active_node != -1:
                    node = namespace.node_by_id(active_node)
                    subprocess.call(["less", node.stdout])
                elif char == ord('L') and active_node != -1:
                    node = namespace.node_by_id(active_node)
                    subprocess.call(["less", node.stderr])
                break

    curses.wrapper(run_top)


@cli.command()
@click.pass_obj
def destroy(namespace):
    """Stop all nodes and removes all data from active namespace"""
    namespace.destroy()


def run_client(*args):
    """Run the casper client, compiling it if necessary, with the given command-line args"""
    return subprocess.check_call(
        [
            "cargo",
            "run",
            "--quiet",
            "--manifest-path={}".format(os.path.join(BASE_DIR, "client", "Cargo.toml")),
            "--",
        ]
        + list(args)
    )


def create_timestamp(offset, utc_now):
    """Creates a chainspec-compatible timestamp with an offset given in seconds"""
    return (utc_now + timedelta(seconds=offset)).isoformat("T") + "Z"


def systemd_run(
    name, description, binary, properties={}, deps=[], run_args=[], app_args=[], env={}
):
    """Calls systemd-run with various arguments"""
    args = [
        "systemd-run",
        "--quiet",
        "--user",
        "--unit",
        name,
        "--description",
        description,
        "--no-block",
    ]

    for (k, v) in properties.items():
        args.append("--property={}={}".format(k, v))

    for dep in deps:
        args.append("--property=After={}.service".format(dep))
        args.append("--property=Requires={}.service".format(dep))

    for (k, v) in env.items():
        args.append("--setenv={}={}".format(k, v))
    args.extend(run_args)

    args.append("--")
    args.append(os.path.abspath(binary))
    args.extend(app_args)

    subprocess.check_call(args)


def progress(msg, *args):
    """Outputs a step in a process"""
    click.secho(" * ", fg="green", nl=False)
    click.echo(msg.format(*args))


def info(msg, *args):
    """Outputs information"""
    click.echo("   ", nl=False)
    click.secho(msg.format(*args), fg="white")


def unit_exists(name):
    """Checks if a unit exists on systemd"""
    output = subprocess.check_output(
        ["systemctl", "--user", "list-units", "--all", name]
    )
    return name in output.decode("utf8")


def unit_is_active(name):
    """Checks if a unit is active (i.e. running) on systemd"""
    return subprocess.call(["systemctl", "--user", "is-active", "--quiet", name]) == 0


def parse_systemd_timestamp(ts):
    """Returns the systemd timestamp as a `datetime` IN LOCAL TIME"""
    weekday, remainder = ts.split(" ", 1)
    return datetime.strptime(remainder, "%Y-%m-%d %H:%M:%S %Z")


def human_timedelta(secs):
    """Format a delta given in seconds human readable"""
    DAY = 24 * 3600
    HOUR = 3600
    MINUTE = 60

    secs = int(secs)

    output = ""

    if secs > DAY:
        output += "{}d ".format(secs // DAY)
        secs %= DAY

    if secs > HOUR:
        output += "{}h ".format(secs // HOUR)
        secs %= HOUR

    if secs > MINUTE:
        output += "{}m ".format(secs // MINUTE)
        secs %= MINUTE

    output += "{}s".format(secs)

    return output


def get_unit(name):
    """Get systemd information about a unit"""
    lines = subprocess.check_output(
        ["systemctl", "--user", "show", name], universal_newlines=True
    ).split("\n")

    pairs = (line.split("=", 1) for line in lines if line.strip())

    return {key: value for key, value in pairs}


def last_lines_of_file(filename, n_lines=1):
    """Returns the last line of a file if it is within 1kb"""
    BUFFER_PER_LINE = 1024

    f = open(filename, "rb")
    length = f.seek(0, 2)
    f.seek(max(length - BUFFER_PER_LINE * n_lines, 0))
    tail_lines = [line for line in f.read().splitlines() if line.strip()]

    if not tail_lines:
        return ""

    return tail_lines[-1].decode("UTF8")


def ellipses(s, length=50):
    """Ellipses text"""
    if length < 4:
        length = 4

    if len(s) <= length:
        return s

    return s[: length - 3] + "..."


if __name__ == "__main__":
    """Main entry point"""

    try:
        cli()
    except RunDevError as e:
        click.secho("error: {}".format(e), fg="yellow")
