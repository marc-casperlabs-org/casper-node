#!/usr/bin/env python3

# run-dev.sh successor. Requires python `click` and `toml` packages installed, which should be
# available in all commonly used distros.

from datetime import datetime, timedelta
import os
import random
import shutil
import subprocess
import sys
import time

import click
import toml

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
CHAINSPEC_TEMPLATE = os.path.join(BASE_DIR, "resources", "local", "chainspec.toml")
CONFIG_TEMPLATE = os.path.join(BASE_DIR, "resources", "local", "config.toml")

# TODO: TRUSTED HASH
#     TODO systemctl --user reset-failed node-$ID || true
#         TRUSTED_HASH_ARG=--config-ext=node.trusted_hash="${TRUSTED_HASH}"

#: Singleton holding the path of a compiled node. Use `node_path()` instead.
_node_path = None


def node_path():
    """Compiles the casper node once, returns path to `casper-node` binary"""
    global _node_path

    if not _node_path:
        progress("compiling casper-node")
        subprocess.check_call(
            [
                "cargo",
                "build",
                "--release",
                "--quiet",
                "--manifest-path={}".format(
                    os.path.join(BASE_DIR, "node", "Cargo.toml")
                ),
            ]
        )
        _node_path = os.path.abspath(
            os.path.join(BASE_DIR, "target", "release", "casper-node")
        )

    return _node_path


class RunDevError(Exception):
    """A run-dev exception"""

    pass


class Namespace:
    def __init__(self, name, base_dir, num_nodes, genesis_offset, validator_slots, node_memory_limit):
        """A namespace containing all data required to run a full network.

        Includes configuration files and runtime state for all nodes, as well as chainspec data"""
        self.name = name
        self.ns_dir = os.path.join(base_dir, name)
        self.chainspec_toml = os.path.abspath(
            os.path.join(self.ns_dir, "chainspec.toml")
        )
        self.num_nodes = num_nodes
        self.genesis_offset = genesis_offset
        self.validator_slots = validator_slots
        self.node_memory_limit = node_memory_limit

        # Precalculated paths and values.
        self.accounts_csv = os.path.abspath(os.path.join(self.ns_dir, "accounts.csv"))
        self.bootstrap_port = random.Random(self.name).randint(60000, 65000)
        self.nodes = tuple(Node(self, id) for id in range(self.num_nodes))

    def add_asset(self, input_path):
        """Copies a file into the namespace, returns the resulting path"""
        asset_dir = os.path.join(self.ns_dir, "assets")
        if not os.path.exists(asset_dir):
            os.makedirs(asset_dir)

        basename = os.path.basename(input_path)
        dest = os.path.join(asset_dir, basename)
        progress("adding {}".format(basename))
        shutil.copy(input_path, dest)
        return dest

    def destroy(self):
        """Destroys a namespace, stopping all nodes and removing its data"""
        if self.is_initialized():
            for node in self.nodes:
                node.stop()
            progress("destroying namespace {}".format(self.name))
            shutil.rmtree(self.ns_dir)
        else:
            info("namespace {} does not exist".format(self.name))

    def initialize(self):
        """Initializes a namespace"""
        if not self.is_initialized():
            os.makedirs(self.ns_dir)

            # Setup a chainspec
            chainspec = toml.load(open(CHAINSPEC_TEMPLATE))
            chainspec_base = os.path.dirname(CHAINSPEC_TEMPLATE)

            chainspec["genesis"]["mint_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base, chainspec["genesis"]["mint_installer_path"]
                )
            )
            chainspec["genesis"]["pos_installer_path"] = self.add_asset(
                os.path.join(chainspec_base, chainspec["genesis"]["pos_installer_path"])
            )
            chainspec["genesis"]["standard_payment_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base,
                    chainspec["genesis"]["standard_payment_installer_path"],
                )
            )
            chainspec["genesis"]["auction_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base, chainspec["genesis"]["auction_installer_path"]
                )
            )
            chainspec["genesis"]["accounts_path"] = self.accounts_csv
            chainspec["genesis"]["validator_slots"] = self.validator_slots

            # Setup genesis timestamp
            genesis_ts = create_timestamp(self.genesis_offset)
            chainspec["genesis"]["timestamp"] = genesis_ts

            # Save the updated chainspec.
            toml.dump(chainspec, open(self.chainspec_toml, 'w'))

            # Setup each node and write accounts file
            accounts = open(self.accounts_csv, "w")
            for node in self.nodes:
                node.initialize()

                # Generate keys for each node and collect them in accounts.csv
                motes = 1000000000000000
                weight = 10000000000000

                progress(
                    "adding account {} with {} motes and {} weight".format(
                        click.style(node.hex_key[:7], fg="cyan", reset=True),
                        motes,
                        weight,
                    )
                )
                accounts.write("{},{},{}\n".format(node.hex_key, motes, weight))

    def is_initialized(self):
        """Returns whether or not the namespace has been intialized.

        Raises an exception if it has been initialized with a different number of nodes"""
        if os.path.exists(self.accounts_csv):
            return True

        if os.path.exists(self.ns_dir):
            raise RunDevError(
                "your namespace is corrupted, please remove {} manually".format(
                    self.ns_dir
                )
            )

        return False

    def node_by_id(self, id):
        """Returns a single node by id."""
        if id >= len(self.nodes):
            raise RunDevError("No such node: {}".format(id))
        return self.nodes[id]

    def nodes_by_ids(self, ids):
        """Returns nodes by id.

        Returns all nodes if `ids` is empty"""
        if not ids:
            return self.nodes

        return [self.node_by_id(id) for id in ids]


class Node:
    def __init__(self, namespace, id):
        # Basic info.
        self.namespace = namespace
        self.id = id
        self.dir = os.path.join(namespace.ns_dir, "node-{}".format(id))
        self.name = "{}_node-{}".format(namespace.name, id)

        # Derived paths and names.
        self.config_toml = os.path.join(self.dir, "config.toml")
        self.key_dir = os.path.join(self.dir, "keys")
        self.key_path = os.path.join(self.key_dir, "secret_key.pem")
        self.storage_dir = os.path.join(self.dir, "storage")
        self.stderr = os.path.join(self.dir, "stderr")
        self.stdout = os.path.join(self.dir, "stdout")
        self.unit = "{}.service".format(self.name)

        # Ports.
        self.http_port = (
            30000 + random.Random(self.name).randint(0, 150) * 200 + self.id
        )

        # Load key if possible.
        self.try_load_hex_key()

    @property
    def bootstrap_addr(self):
        """Bootstrap address used by node."""
        return "127.0.0.1:{}".format(self.namespace.bootstrap_port)

    @property
    def is_bootstrap(self):
        """Is this node a bootstrap node?"""
        return self.id == 0

    def initialize(self):
        """Initializes a node, including storage and config"""
        # Generate a key
        progress("generating key for node {} [{}]".format(self.id, self.key_dir))
        run_client("keygen", self.key_dir)
        self.try_load_hex_key()

        # Ensure the storage dir exists
        if not os.path.exists(self.storage_dir):
            progress("creating storage dir for node {}", self.id)
            os.makedirs(self.storage_dir)

        # Create configuration
        config = toml.load(open(CONFIG_TEMPLATE))
        config["node"]["chainspec_config_path"] = self.namespace.chainspec_toml
        config["consensus"]["secret_key_path"] = self.key_path
        config["storage"]["path"] = self.storage_dir

        # Setup networking/IPs
        config["network"]["gossip_interval"] = 1000
        config["network"]["systemd_support"] = True
        config["http_server"]["address"] = "127.0.0.1:{}".format(self.http_port)

        if self.is_bootstrap:
            # Bootstrap node.
            config["network"]["bind_address"] = self.bootstrap_addr
            config["network"]["public_address"] = self.bootstrap_addr
            config["network"]["known_addresses"] = []
        else:
            config["network"]["known_addresses"] = [self.bootstrap_addr]
            config["network"]["bind_address"] = "127.0.0.1:0"
            config["network"]["public_address"] = "127.0.0.1:0"

        # Save config
        progress(
            "saving node configuration for node {} [{}]", self.id, self.config_toml,
        )
        toml.dump(config, open(self.config_toml, "w"))

    def start(self):
        """Start a node, without resetting its state."""
        if unit_exists(self.unit):
            # Unit already exists. Check if it is healthy.
            if unit_is_active(self.unit):
                info(
                    "{} is already running, skipping. stop it first if you want to restart",
                    self.unit,
                )
                return

            # Unit is _not_ healthy. Clean it up
            progress("resetting failed {} before starting", self.unit)
            subprocess.check_call(["systemctl", "--user", "reset-failed", self.unit])

        deps = [] if id == 0 else [self.name]
        if id != 0:
            deps

        progress("starting node {}", self.id)
        systemd_run(
            self.name,
            "casperlabs node {} in namespace {}".format(self.id, self.namespace.name),
            node_path(),
            properties={
                "Type": "notify",
                "TimeoutSec": 10,
                "WorkingDirectory": self.dir,
                "StandardOutput": "file:{}".format(self.stdout),
                "StandardError": "file:{}".format(self.stderr),
                "LimitDATA": self.namespace.node_memory_limit,
            },
            deps=deps,
            env={"RUST_LOG": "info",},
            app_args=["validator", self.config_toml],
        )

    def status(self, local_now):
        """Returns status information of a node"""
        rv = {
            "id": str(self.id),
            "state": "",
            "since": "",
            "info": "",
        }

        us = get_unit(self.unit)
        rv["state"] = us["ActiveState"]

        if "StateChangeTimestamp" in us:
            state_changed = parse_systemd_timestamp(us["StateChangeTimestamp"])
            rv["since"] = human_timedelta((local_now -state_changed).total_seconds())

        # TODO: Fill in active state.
        # We use the last line from stderr, unless the node did not crash.
        log_source = self.stderr
        if rv["state"] == "XXXXXX":
            log_source = self.stdout

        if os.path.exists(log_source):
            rv["info"] = ellipses(last_line_of_file(log_source), 35)


        return rv

    def stop(self):
        """Stops the node, retaining logs and state."""
        progress("stopping node {}", self.id)

        if not unit_exists(self.unit):
            info("{} does not exist, skipping", self.unit)
            return

        if not unit_is_active(self.unit):
            info("{} is not running, skipping", self.unit)
            return

        subprocess.call(["systemctl", "--user", "stop", self.unit])

    def try_load_hex_key(self):
        """Tries to load and set the hex key of the node"""
        hex_key_path = os.path.join(self.key_dir, "public_key_hex")
        if os.path.exists(hex_key_path):
            self.hex_key = open(hex_key_path).read().strip()


@click.group()
@click.option(
    "-b", "--base-dir", default="/tmp/run-dev", help="Base directory to store data in"
)
@click.option(
    "--namespace", "name", default="default", help="Namespace to run nodes in"
)
@click.option(
    "-g",
    "--genesis-offset",
    default=15,
    help="(for new namespace) Offset for genesis in seconds",
)
@click.option(
    "-m",
    "--memory-limit",
    'node_memory_limit',
    default="400M",
    help="(for new namespace) Memory limit per node",
)
@click.option(
    "-n",
    "--num-nodes",
    default=5,
    type=int,
    help="(for new namespace) Total number of nodes in the namespace",
)
@click.option(
    "--validator-slots",
    default=5,
    help="(for new namespace) Number of validator slots in an auction",
)
@click.pass_context
def cli(ctx, **kwargs):
    ctx.obj = Namespace(**kwargs)


@cli.command()
@click.option(
    "-f", "--force", is_flag=True, help="destroy namespace if it already exists"
)
@click.pass_obj
def create(namespace, force):
    """Creates a new namespace"""
    if namespace.is_initialized():
        if not force:
            raise RunDevError("namespace already initialized")
        namespace.destroy()

    namespace.initialize()


@cli.command()
@click.argument("node_id", type=int)
@click.option("-e", "--stderr", is_flag=True, help="Show stderr logs instead of stdout")
@click.pass_obj
def logs(namespace, node_id, stderr):
    """Stop a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        raise RunDevError("cannot stop nodes, no namespace initialized")

    node = namespace.node_by_id(node_id)
    log_file = node.stderr if stderr else node.stdout

    shutil.copyfileobj(open(log_file, 'rb'), sys.stdout.buffer)

@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def start(namespace, node_ids):
    """Start a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        namespace.initialize()

    for node in namespace.nodes_by_ids(node_ids):
        node.start()


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def status(namespace, node_ids):
    """Output status information about nodes"""
    if not namespace.is_initialized():
        raise RunDevError("namespace not initialized, cannot get node status")

    local_now = datetime.now()
    rows = [node.status(local_now) for node in namespace.nodes_by_ids(node_ids)]

    if not rows:
        return

    max_widths = {
        col: max(len(row[col]) for row in rows + [{key: key for key in rows[0].keys()}])
        for col in rows[0].keys()
    }

    # Print headings.
    for header in rows[0].keys():
        click.echo(header.upper().ljust(max_widths[header]), nl=False)
        click.echo(" ", nl=False)
    click.echo("")

    # Title separator
    for header in rows[0].keys():
        click.echo("-" * max_widths[header], nl=False)
        click.echo(" ", nl=False)

    click.echo("")

    for row in rows:
        for key, value in row.items():
            click.echo(value.ljust(max_widths[key]), nl=False)
            click.echo(" ", nl=False)
        click.echo("")


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def stop(namespace, node_ids):
    """Stop a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        raise RunDevError("cannot stop nodes, no namespace initialized")

    for node in namespace.nodes_by_ids(node_ids):
        node.stop()


@cli.command()
@click.pass_obj
def destroy(namespace):
    """Stop all nodes and removes all data from active namespace"""
    namespace.destroy()


def run_client(*args):
    """Run the casper client, compiling it if necessary, with the given command-line args"""
    return subprocess.check_call(
        [
            "cargo",
            "run",
            "--quiet",
            "--manifest-path={}".format(os.path.join(BASE_DIR, "client", "Cargo.toml")),
            "--",
        ]
        + list(args)
    )


def create_timestamp(offset):
    """Creates a chainspec-compatible timestamp with an offset given in seconds"""
    return (datetime.utcnow() + timedelta(seconds=offset)).isoformat("T") + "Z"


def systemd_run(
    name, description, binary, properties={}, deps=[], run_args=[], app_args=[], env={}
):
    """Calls systemd-run with various arguments"""
    args = [
        "systemd-run",
        "--quiet",
        "--user",
        "--unit",
        name,
        "--description",
        description,
        "--no-block",
    ]

    for (k, v) in properties.items():
        args.append("--property={}={}".format(k, v))

    for dep in deps:
        args.append("--property=After={}.service".format(dep))
        args.append("--property=Requires={}.service".format(dep))

    for (k, v) in env.items():
        args.append("--setenv={}={}".format(k, v))
    args.extend(run_args)

    args.append("--")
    args.append(os.path.abspath(binary))
    args.extend(app_args)

    subprocess.check_call(args)


def progress(msg, *args):
    """Outputs a step in a process"""
    click.secho(" * ", fg="green", nl=False)
    click.echo(msg.format(*args))


def info(msg, *args):
    """Outputs information"""
    click.echo("   ", nl=False)
    click.secho(msg.format(*args), fg="white")


def unit_exists(name):
    """Checks if a unit exists on systemd"""
    output = subprocess.check_output(
        ["systemctl", "--user", "list-units", "--all", name]
    )
    return name in output.decode("utf8")


def unit_is_active(name):
    """Checks if a unit is active (i.e. running) on systemd"""
    return subprocess.call(["systemctl", "--user", "is-active", "--quiet", name]) == 0


def parse_systemd_timestamp(ts):
    """Returns the systemd timestamp as a `datetime` IN LOCAL TIME"""
    weekday, remainder = ts.split(' ', 1)
    return datetime.strptime(remainder, '%Y-%m-%d %H:%M:%S %Z')


def human_timedelta(secs):
    """Format a delta given in seconds human readable"""
    DAY = 24*3600
    HOUR = 3600
    MINUTE = 60

    secs = int(secs)

    output = ""

    if secs > DAY:
        output += "{}d ".format(secs // DAY)
        secs %= DAY

    if secs > HOUR:
        output += "{}h ".format(secs // HOUR)
        secs %= HOUR

    if secs > MINUTE:
        output += "{}m ".format(secs // MINUTE)
        secs %= MINUTE

    output += "{}s".format(secs)

    return output


def get_unit(name):
    """Get systemd information about a unit"""
    lines = subprocess.check_output(
        ["systemctl", "--user", "show", name], universal_newlines=True
    ).split("\n")

    pairs = (line.split("=", 1) for line in lines if line.strip())

    return {key: value for key, value in pairs}


def last_line_of_file(filename):
    """Returns the last line of a file if it is within 1kb"""
    f = open(filename, 'rb')
    length = f.seek(0, 2)
    f.seek(max(length-1024, 0))
    tail_lines = [line for line in f.read().splitlines() if line.strip()]

    if not tail_lines:
        return ""

    return tail_lines[-1].decode("UTF8")


def ellipses(s, length=50):
    """Ellipses text"""
    if length < 4:
        length = 4

    if len(s) <= length:
        return s

    return s[:length-3] + "..."


if __name__ == "__main__":
    """Main entry point"""

    try:
        cli()
    except RunDevError as e:
        click.secho("error: {}".format(e), fg="yellow")
