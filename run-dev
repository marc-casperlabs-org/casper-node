#!/usr/bin/env python3

from datetime import datetime, timedelta
import os
import random
import shutil
import subprocess
import time

import click
import toml

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
CHAINSPEC_TEMPLATE = os.path.join(BASE_DIR, "resources", "local", "chainspec.toml")
CONFIG_TEMPLATE = os.path.join(BASE_DIR, "resources", "local", "config.toml")

# TODO: TRUSTED HASH
#     TODO systemctl --user reset-failed node-$ID || true
#         TRUSTED_HASH_ARG=--config-ext=node.trusted_hash="${TRUSTED_HASH}"

#: Singleton holding the path of a compiled node. Use `node_path()` instead.
_node_path = None


def node_path():
    """Compiles the casper node once, returns path to `casper-node` binary"""
    global _node_path

    if not _node_path:
        progress("compiling casper-node")
        subprocess.check_call(
            [
                "cargo",
                "build",
                "--release",
                "--quiet",
                "--manifest-path={}".format(
                    os.path.join(BASE_DIR, "node", "Cargo.toml")
                ),
            ]
        )
        _node_path = os.path.abspath(
            os.path.join(BASE_DIR, "target", "release", "casper-node")
        )

    return _node_path


class RunDevError(Exception):
    """A run-dev exception"""

    pass


class Namespace:
    def __init__(self, name, base_dir, num_nodes, genesis_offset, validator_slots):
        """A namespace containing all data required to run a full network.

        Includes configuration files and runtime state for all nodes, as well as chainspec data"""
        self.name = name
        self.ns_dir = os.path.join(base_dir, name)
        self.chainspec_toml = os.path.abspath(
            os.path.join(self.ns_dir, "chainspec.toml")
        )
        self.num_nodes = num_nodes
        self.genesis_offset = genesis_offset
        self.validator_slots = validator_slots

        # Precalculated paths and values.
        self.accounts_csv = os.path.abspath(os.path.join(self.ns_dir, "accounts.csv"))
        self.bootstrap_port = random.Random(self.name).randint(60000, 65000)
        self.nodes = tuple(Node(self, id) for id in range(self.num_nodes))

    def add_asset(self, input_path):
        """Copies a file into the namespace, returns the resulting path"""
        asset_dir = os.path.join(self.ns_dir, "assets")
        if not os.path.exists(asset_dir):
            os.makedirs(asset_dir)

        basename = os.path.basename(input_path)
        dest = os.path.join(asset_dir, basename)
        progress("adding {}".format(basename))
        shutil.copy(input_path, dest)
        return dest

    def destroy(self):
        """Destroys a namespace, stopping all nodes and removing its data"""
        if self.is_initialized():
            for node in self.nodes:
                node.stop()
            progress("destroying namespace {}".format(self.name))
            shutil.rmtree(self.ns_dir)
        else:
            info("namespace {} does not exist".format(self.name))

    def initialize(self):
        """Initializes a namespace"""
        if not self.is_initialized():
            os.makedirs(self.ns_dir)

            # Setup a chainspec
            chainspec = toml.load(open(CHAINSPEC_TEMPLATE))
            chainspec_base = os.path.dirname(CHAINSPEC_TEMPLATE)

            chainspec["genesis"]["mint_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base, chainspec["genesis"]["mint_installer_path"]
                )
            )
            chainspec["genesis"]["pos_installer_path"] = self.add_asset(
                os.path.join(chainspec_base, chainspec["genesis"]["pos_installer_path"])
            )
            chainspec["genesis"]["standard_payment_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base,
                    chainspec["genesis"]["standard_payment_installer_path"],
                )
            )
            chainspec["genesis"]["auction_installer_path"] = self.add_asset(
                os.path.join(
                    chainspec_base, chainspec["genesis"]["auction_installer_path"]
                )
            )
            chainspec["genesis"]["accounts_path"] = self.accounts_csv
            chainspec["genesis"]["validator_slots"] = self.validator_slots

            # Setup genesis timestamp
            genesis_ts = create_timestamp(self.genesis_offset)
            chainspec["genesis"]["timestamp"] = genesis_ts

            # Setup each node and write accounts file
            accounts = open(self.accounts_csv, "w")
            for node in self.nodes:
                node.initialize()

                # Generate keys for each node and collect them in accounts.csv
                motes = 1000000000000000
                weight = 10000000000000

                progress(
                    "adding account {} with {} motes and {} weight".format(
                        click.style(node.hex_key[:7], fg="cyan", reset=True),
                        motes,
                        weight,
                    )
                )
                accounts.write("{},{},{}\n".format(node.hex_key, motes, weight))

    def is_initialized(self):
        """Returns whether or not the namespace has been intialized.

        Raises an exception if it has been initialized with a different number of nodes"""
        if os.path.exists(self.accounts_csv):
            return True

        if os.path.exists(self.ns_dir):
            raise RunDevError(
                "your namespace is corrupted, please remove {} manually".format(
                    self.ns_dir
                )
            )

        return False

    def nodes_by_ids(self, ids):
        """Returns nodes by id.

        Returns all nodes if `ids` is empty"""
        if not ids:
            return self.nodes
        return [self.nodes(id) for id in ids]


class Node:
    def __init__(self, namespace, id):
        # Basic info.
        self.namespace = namespace
        self.id = id
        self.dir = os.path.join(namespace.ns_dir, "node-{}".format(id))
        self.name = "{}_node-{}".format(namespace.name, id)

        # Derived paths and names.
        self.config_toml = os.path.join(self.dir, "config.toml")
        self.key_dir = os.path.join(self.dir, "keys")
        self.key_path = os.path.join(self.key_dir, "secret_key.pem")
        self.storage_dir = os.path.join(self.dir, "storage")
        self.stderr = os.path.join(self.dir, "stderr")
        self.stdout = os.path.join(self.dir, "stdout")
        self.unit = "{}.service".format(self.name)

        # Ports.
        self.http_port = (
            30000 + random.Random(self.name).randint(0, 150) * 200 + self.id
        )

        # Load key if possible.
        self.try_load_hex_key()

    @property
    def bootstrap_addr(self):
        """Bootstrap address used by node."""
        return self.namespace.bootstrap_addr

    def initialize(self):
        """Initializes a node, including storage and config"""
        # Generate a key
        progress("generating key for node {} [{}]".format(self.id, self.key_dir))
        run_client("keygen", self.key_dir)
        self.try_load_hex_key()

        # Ensure the storage dir exists
        if not os.path.exists(self.storage_dir):
            progress("creating storage dir for node {}", self.id)
            os.makedirs(self.storage_dir)

        # Create configuration
        config = toml.load(open(CONFIG_TEMPLATE))
        config["node"]["chainspec_config_path"] = self.namespace.chainspec_toml
        config["consensus"]["secret_key_path"] = self.key_path
        config["storage"]["path"] = self.storage_dir

        # Setup networking/IPs
        bootstrap_addr = "127.0.0.1:{}".format(self.namespace.bootstrap_port)
        config["network"]["gossip_interval"] = 1000
        config["network"]["known_addresses"] = [bootstrap_addr]
        config["network"]["systemd_support"] = True
        config["http_server"]["address"] = "127.0.0.1:{}".format(self.http_port)

        if id == 1:
            # Bootstrap node.
            config["network"]["bind_address"] = bootstrap_addr
            config["network"]["public_address"] = bootstrap_addr
        else:
            config["network"]["bind_address"] = "127.0.0.1:0"
            config["network"]["public_address"] = "127.0.0.1:0"

        # Save config
        progress(
            "saving node configuration for node {} [{}]", self.id, self.config_toml,
        )
        toml.dump(config, open(self.config_toml, "w"))

    def start(self):
        """Start a node, without resetting its state."""
        if unit_exists(self.unit):
            # Unit already exists. Check if it is healthy.
            if unit_is_active(self.unit):
                info(
                    "{} is already running, skipping. stop it first if you want to restart",
                    service_name,
                )
                return

            # Unit is _not_ healthy. Clean it up
            progress("resetting failed {} before starting", self.unit)
            subprocess.check_call(["systemctl", "--user", "reset-failed", self.unit])

        deps = [] if id == 0 else [self.name]
        if id != 0:
            deps

        progress("starting node {}", self.id)
        systemd_run(
            self.name,
            "casperlabs node {} in namespace {}".format(self.id, self.namespace.name),
            node_path(),
            properties={
                "Type": "notify",
                "TimeoutSec": 10,
                "WorkingDirectory": self.dir,
                "StandardOutput": "file:{}".format(self.stdout),
                "StandardError": "file:{}".format(self.stderr),
                "LimitDATA": "400M",  # TODO Make configurable
            },
            deps=deps,
            env={"RUST_LOG": "info",},
            app_args=["validator", self.config_toml],
        )

    def status(self):
        state = "unknown"
        info = ""

        if not unit_exists(self.unit):
            state = "missing"
        elif not unit_is_active(self.unit):
            state = "inactive"
        else:
            state = "running"

        return {
            "id": self.id,
            "state": state,
            "info": info,
        }

    def stop(self):
        """Stops the node, retaining logs and state."""
        progress("stopping node {}", self.id)

        if not unit_exists(self.unit):
            info("{} does not exist, skipping", self.unit)
            return

        if not unit_is_active(self.unit):
            info("{} is not running, skipping", self.unit)
            return

        subprocess.call(["systemctl", "--user", "stop", self.unit])

    def try_load_hex_key(self):
        """Tries to load and set the hex key of the node"""
        hex_key_path = os.path.join(self.key_dir, "public_key_hex")
        if os.path.exists(hex_key_path):
            self.hex_key = open(hex_key_path).read().strip()


@click.group()
@click.option(
    "-b", "--base-dir", default="/tmp/run-dev", help="Base directory to store data in"
)
@click.option(
    "--namespace", "name", default="default", help="Namespace to run nodes in"
)
@click.option(
    "-n",
    "--num-nodes",
    default=5,
    type=int,
    help="(for new namespace) Total number of nodes in the namespace",
)
@click.option(
    "-g",
    "--genesis-offset",
    default=15,
    help="(for new namespace) Offset for genesis in seconds",
)
@click.option(
    "--validator-slots",
    default=5,
    help="(for new namespace) Number of validator slots in an auction",
)
@click.pass_context
def cli(ctx, **kwargs):
    ctx.obj = Namespace(**kwargs)


@cli.command()
@click.option(
    "-f", "--force", is_flag=True, help="destroy namespace if it already exists"
)
@click.pass_obj
def create(namespace, force):
    """Creates a new namespace"""
    if namespace.is_initialized():
        if not force:
            raise RunDevError("namespace already initialized")
        namespace.destroy()

    namespace.initialize()


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def start(namespace, node_ids):
    """Start a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        namespace.initialize()

    for node in namespace.nodes_by_ids(node_ids):
        node.start()


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def status(namespace, node_ids):
    """Output status information about nodes"""
    if not namespace.is_initialized():
        raise RunDevError("namespace not initialized, cannot get node status")

    tpl = "{id:4}  {state:8}  {info}"
    print(tpl.format(id="Node", state="State", info="Info"))

    for node in namespace.nodes_by_ids(node_ids):
        status = node.status()
        print(tpl.format(**status))


@cli.command()
@click.argument("node_ids", type=int, nargs=-1)
@click.pass_obj
def stop(namespace, node_ids):
    """Stop a specific (or all) nodes in the namespace"""
    if not namespace.is_initialized():
        raise RunDevError("cannot stop nodes, no namespace initialized")

    for node in namespace.nodes_by_ids(node_ids):
        node.stop()


@cli.command()
@click.pass_obj
def destroy(namespace):
    """Stop all nodes and removes all data from active namespace"""
    namespace.destroy()


def run_client(*args):
    """Run the casper client, compiling it if necessary, with the given command-line args"""
    return subprocess.check_call(
        [
            "cargo",
            "run",
            "--quiet",
            "--manifest-path={}".format(os.path.join(BASE_DIR, "client", "Cargo.toml")),
            "--",
        ]
        + list(args)
    )


def create_timestamp(offset):
    """Creates a chainspec-compatible timestamp with an offset given in seconds"""
    return (datetime.utcnow() + timedelta(seconds=offset)).isoformat("T") + "Z"


def systemd_run(
    name, description, binary, properties={}, deps=[], run_args=[], app_args=[], env={}
):
    """Calls systemd-run with various arguments"""
    args = [
        "systemd-run",
        "--quiet",
        "--user",
        "--unit",
        name,
        "--description",
        description,
        "--no-block",
    ]

    for (k, v) in properties.items():
        args.append("--property={}={}".format(k, v))

    for dep in deps:
        args.append("--property=After={}.service".format(dep))
        args.append("--property=Requires={}.service".format(dep))

    for (k, v) in env.items():
        args.append("--setenv={}={}".format(k, v))
    args.extend(run_args)

    args.append("--")
    args.append(os.path.abspath(binary))
    args.extend(app_args)

    subprocess.check_call(args)


def progress(msg, *args):
    """Outputs a step in a process"""
    click.secho(" * ", fg="green", nl=False)
    click.echo(msg.format(*args))


def info(msg, *args):
    """Outputs information"""
    click.echo("   ", nl=False)
    click.secho(msg.format(*args), fg="white")


def unit_exists(name):
    """Checks if a unit exists on systemd"""
    output = subprocess.check_output(
        ["systemctl", "--user", "list-units", "--all", name]
    )
    return name in output.decode("utf8")


def unit_is_active(name):
    """Checks if a unit is active (i.e. running) on systemd"""
    return subprocess.call(["systemctl", "--user", "is-active", "--quiet", name]) == 0


if __name__ == "__main__":
    """Main entry point"""
    try:
        cli()
    except RunDevError as e:
        click.secho("error: {}".format(e), fg="yellow")
